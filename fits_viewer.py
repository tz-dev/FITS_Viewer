#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
FITS Viewer
-----------
Author: Generated by Grok 3 (xAI)
Date: July 05, 2025
Version: 1.0
Description:
    A lightweight Python-based GUI tool for viewing and navigating tabular data
    in FITS (Flexible Image Transport System) files. This tool dynamically loads
    column names from the specified FITS file (HDU 1) and allows users to select
    dynamically loaded columns, adjust display settings and navigate through pages.
    The tool supports large files via memory mapping (memmap=True) and includes
    features like customizable row counts, column widths, and font sizes.

Requirements:
    - Python 3.x
    - astropy
    - numpy
    - tkinter (typically included with Python)

Usage:
    Run with: python fits_browser.py <fits_file_path>
    or use the provided fview.bat script: fview <fits_file_path>
    Use Mousewheel for page up/down

Limitations:
    - Supports only tabular data in HDU 1.
    - Large files (>6 GB) may still strain memory despite memmap.
    - No search functionality (removed per user request).

License:
    MIT License (see LICENSE file or contact author for details)
"""

import sys
from astropy.io import fits
import tkinter as tk
from tkinter import ttk, scrolledtext
import numpy as np
import os

# ===== CONFIG =====
EXT = 1
PAGE_SIZE = 50

WINDOW_WIDTH = 1800
WINDOW_HEIGHT = 950

FONT_SIZE = 10
FONT_NAME = "Consolas"
BG_COLOR = "black"
FG_COLOR = "lime"
DEFAULT_COLUMN_WIDTH = 15
# ==================

class FITSViewer:
    def __init__(self, root, file_path):
        self.root = root
        self.root.title("FITS Viewer")
        self.root.geometry(f"{WINDOW_WIDTH}x{WINDOW_HEIGHT}")

        self.font_size = FONT_SIZE
        self.column_width = DEFAULT_COLUMN_WIDTH
        self.page = 0

        # Open FITS file with lazy loading
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"File {file_path} not found.")
        self.hdul = fits.open(file_path, memmap=True)
        self.header = self.hdul[EXT].header
        self.colnames = self.hdul[EXT].columns.names
        self.nrows = self.hdul[EXT].header['NAXIS2']
        self.page_size = PAGE_SIZE

        # Layout
        main_frame = ttk.Frame(root)
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Text output
        self.text = scrolledtext.ScrolledText(
            main_frame,
            font=(FONT_NAME, self.font_size),
            bg=BG_COLOR,
            fg=FG_COLOR
        )
        self.text.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")
        self.text.bind("<MouseWheel>", self.on_mousewheel)
        self.text.bind("<Button-4>", self.on_mousewheel_linux)  # Linux scroll up
        self.text.bind("<Button-5>", self.on_mousewheel_linux)  # Linux scroll down

        # Column selection (right)
        col_frame = ttk.Frame(main_frame)
        col_frame.grid(row=0, column=1, padx=10, pady=10, sticky="ns")
        tk.Label(col_frame, text="Columns:").pack()
        self.column_listbox = tk.Listbox(col_frame, selectmode=tk.MULTIPLE, height=40, exportselection=False, width=30)
        self.column_listbox.pack(fill=tk.Y)
        for name in self.colnames:
            self.column_listbox.insert(tk.END, name)
        for i in range(min(10, len(self.colnames))):
            self.column_listbox.select_set(i)
        ttk.Button(col_frame, text="Update Columns", command=self.display_page).pack(pady=5)

        # Rows and Column Width input (side by side, centered in first row)
        input_frame = ttk.Frame(main_frame)
        input_frame.grid(row=1, column=0, columnspan=2, pady=5)
        main_frame.columnconfigure(0, weight=1)  # Center the input frame

        rows_frame = ttk.Frame(input_frame)
        rows_frame.pack(side=tk.LEFT, padx=5)
        tk.Label(rows_frame, text="Rows per Page:").pack(side=tk.LEFT)
        self.rows_entry = ttk.Entry(rows_frame, width=5)
        self.rows_entry.insert(0, str(self.page_size))
        self.rows_entry.pack(side=tk.LEFT, padx=5)
        ttk.Button(rows_frame, text="Set Rows", command=self.update_page_size).pack(side=tk.LEFT)

        width_frame = ttk.Frame(input_frame)
        width_frame.pack(side=tk.LEFT, padx=5)
        tk.Label(width_frame, text="Col Width:").pack(side=tk.LEFT)
        self.width_entry = ttk.Entry(width_frame, width=5)
        self.width_entry.insert(0, str(self.column_width))
        self.width_entry.pack(side=tk.LEFT, padx=5)
        ttk.Button(width_frame, text="Set Width", command=self.update_column_width).pack(side=tk.LEFT)

        # Controls (all buttons in second row, centered)
        control_frame = ttk.Frame(main_frame)
        control_frame.grid(row=2, column=0, columnspan=2, pady=5)
        ttk.Button(control_frame, text="Previous", command=self.prev_page).grid(row=0, column=1, padx=5)
        ttk.Button(control_frame, text="Next", command=self.next_page).grid(row=0, column=2, padx=5)
        ttk.Button(control_frame, text="A -", command=self.decrease_font).grid(row=0, column=3, padx=5)
        ttk.Button(control_frame, text="A +", command=self.increase_font).grid(row=0, column=4, padx=5)
        control_frame.columnconfigure(0, weight=1)  # Left padding
        control_frame.columnconfigure(5, weight=1)  # Right padding

        # Exit button (bottom right)
        exit_frame = ttk.Frame(main_frame)
        exit_frame.grid(row=2, column=1, padx=25, pady=5, sticky="e")  # Align to bottom right
        ttk.Button(exit_frame, text="Exit", command=self.root.quit).pack(side=tk.RIGHT)

        # Status
        self.status = ttk.Label(root, text=f"Page 1 of {int(self.nrows / self.page_size) + 1}, Total Rows: {self.nrows}")
        self.status.pack()

        main_frame.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)

        self.display_page()

    def get_selected_columns(self):
        indices = self.column_listbox.curselection()
        return [self.colnames[i] for i in indices] if indices else self.colnames[:10]

    def display_page(self):
        self.text.config(state='normal')
        self.text.delete("1.0", tk.END)
        start = self.page * self.page_size
        end = min(start + self.page_size, self.nrows)
        columns = self.get_selected_columns()

        header = "".join(name.ljust(self.column_width) for name in columns)
        self.text.insert(tk.END, header + "\n")
        self.text.insert(tk.END, "-" * len(header) + "\n")

        with fits.open(self.hdul.filename(), memmap=True) as hdul:
            data = hdul[EXT].data[start:end]
            for row in data:
                vals = [
                    str(row[name])[:self.column_width - 1].ljust(self.column_width) if not isinstance(row[name], (np.floating, np.integer)) or not np.isnan(row[name])
                    else "NaN".ljust(self.column_width) for name in columns
                ]
                self.text.insert(tk.END, "".join(vals) + "\n")

        self.text.config(state='disabled')
        self.status.config(text=f"Page {self.page + 1} of {int(self.nrows / self.page_size) + 1}, Total Rows: {self.nrows}, Displayed: {end - start}")

    def next_page(self):
        if (self.page + 1) * self.page_size < self.nrows:
            self.page += 1
            self.display_page()

    def prev_page(self):
        if self.page > 0:
            self.page -= 1
            self.display_page()

    def on_mousewheel(self, event):
        if event.delta < 0:
            self.next_page()
        elif event.delta > 0:
            self.prev_page()

    def on_mousewheel_linux(self, event):
        if event.num == 4:
            self.prev_page()
        elif event.num == 5:
            self.next_page()

    def increase_font(self):
        self.font_size += 1
        self.text.configure(font=(FONT_NAME, self.font_size))

    def decrease_font(self):
        if self.font_size > 6:
            self.font_size -= 1
            self.text.configure(font=(FONT_NAME, self.font_size))

    def update_column_width(self):
        try:
            new_width = int(self.width_entry.get())
            if new_width > 2:
                self.column_width = new_width
                self.display_page()
        except ValueError:
            self.status.config(text="Invalid column width")

    def update_page_size(self):
        try:
            new_size = int(self.rows_entry.get())
            if new_size > 0 and new_size <= 1000:  # Limit to reasonable range
                self.page_size = new_size
                self.page = 0  # Reset to first page
                self.display_page()
                self.status.config(text=f"Page 1 of {int(self.nrows / self.page_size) + 1}, Total Rows: {self.nrows}")
        except ValueError:
            self.status.config(text="Invalid number of rows")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: py fits_browser.py <fits_file_path>")
        sys.exit(1)
    file_path = sys.argv[1]
    root = tk.Tk()
    try:
        app = FITSViewer(root, file_path)
        root.mainloop()
    except FileNotFoundError as e:
        print(e)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)