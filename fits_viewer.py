#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
FITS Viewer
-----------
Author: Generated by Grok 3 (xAI), modified
Date: July 06, 2025
Version: 1.2
Description:
    A lightweight Python-based GUI tool for viewing and navigating tabular data
    and images in FITS (Flexible Image Transport System) files. The tool dynamically
    loads column names from the specified FITS file (HDU 1) for tabular data display,
    allowing users to select columns, adjust display settings (row counts, column widths,
    font sizes), and navigate through pages. The Image Viewer displays image HDUs with
    zoom, rotation, and real-time coordinate display (RA/DEC) using WCS. The tool supports
    large files via memory mapping (memmap=True) to optimize performance.

Requirements:
    - Python 3.x
    - astropy (for FITS file handling and WCS)
    - numpy (for data processing)
    - tkinter (typically included with Python, for GUI)
    - PIL (Pillow, for image processing)
    - matplotlib (for image rendering)

Usage:
    Run with: python fits_browser.py <fits_file_path>
    or use the provided fview.bat script: fview <fits_file_path>
    - Use mouse wheel for page up/down in the Table Viewer or image navigation in the Image Viewer.
    - In Image Viewer: Use "Zoom +"/"Zoom -" for scaling, "Rotate Left"/"Rotate Right" for 90-degree rotations,
      "Previous"/"Next" for image navigation, and move the mouse over the image to see RA/DEC coordinates.

Features:
    - Table Viewer: Dynamic column selection, customizable row counts, column widths, and font sizes.
    - Image Viewer: Displays image HDUs with zoom (20% steps), rotation (±90°), navigation,
      and real-time RA/DEC coordinate display using WCS.
    - Memory-efficient handling of large FITS files via memmap=True.
    - Centered GUI windows with consistent size (1800x950 pixels) for both Table and Image Viewers.

Limitations:
    - Supports only tabular data in HDU 1 for the Table Viewer.
    - Image Viewer supports only ImageHDU and PrimaryHDU with non-empty data.
    - RA/DEC coordinate display requires valid WCS in the FITS header.
    - Large files (>6 GB) may still strain memory despite memmap.
    - No search functionality in the Table Viewer.
    - Zoom and rotation in the Image Viewer are applied only to the display, not to the FITS data itself.
"""

import sys
from astropy.io import fits
import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
import numpy as np
import os
from PIL import Image, ImageTk
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import io
from astropy.wcs import WCS

class ImageViewer:
    def __init__(self, hdul):
        self.hdul = hdul
        self.image_hdus = [hdu for hdu in hdul if isinstance(hdu, (fits.ImageHDU, fits.PrimaryHDU)) and hdu.data is not None]
        if not self.image_hdus:
            tk.messagebox.showinfo("No Images", "No image HDUs found in this file.")
            return

        self.index = 0
        self.zoom_factor = 1.0
        self.rotation_angle = 0
        self.wcs = None

        self.win = tk.Toplevel()
        self.win.title("FITS Image Viewer")
        self.win.geometry(f"{WINDOW_WIDTH}x{WINDOW_HEIGHT}")
        self.center_window()

        self.win.bind("<MouseWheel>", self.on_mousewheel)
        self.win.bind("<Button-4>", self.on_mousewheel_linux)
        self.win.bind("<Button-5>", self.on_mousewheel_linux)

        main_frame = ttk.Frame(self.win)
        main_frame.pack(fill=tk.BOTH, expand=True)
        main_frame.grid_columnconfigure(0, weight=1)
        main_frame.grid_columnconfigure(1, weight=0)
        main_frame.grid_rowconfigure(0, weight=1)
        main_frame.grid_rowconfigure(1, weight=0)

        self.canvas = tk.Label(main_frame, bg="black")
        self.canvas.grid(row=0, column=0, sticky="nsew")
        self.canvas.bind("<Motion>", self.on_mouse_move)

        self.info_text = tk.Text(main_frame, width=40, fg="black", font=(FONT_NAME, FONT_SIZE))
        self.info_text.grid(row=0, column=1, sticky="ns")

        btn_frame = ttk.Frame(main_frame)
        btn_frame.grid(row=1, column=0, columnspan=2, sticky="ew", pady=20)
        btn_frame.grid_columnconfigure(0, weight=1)
        btn_frame.grid_columnconfigure(1, weight=0)
        btn_frame.grid_columnconfigure(2, weight=0)
        btn_frame.grid_columnconfigure(3, weight=0)
        btn_frame.grid_columnconfigure(4, weight=0)
        btn_frame.grid_columnconfigure(5, weight=0)
        btn_frame.grid_columnconfigure(6, weight=1)

        zoom_buttons = ttk.Frame(btn_frame)
        zoom_buttons.grid(row=0, column=1, padx=20)
        ttk.Button(zoom_buttons, text="Zoom +", command=self.zoom_in).pack(side=tk.LEFT, padx=5)
        ttk.Button(zoom_buttons, text="Zoom -", command=self.zoom_out).pack(side=tk.LEFT, padx=5)

        nav_buttons = ttk.Frame(btn_frame)
        nav_buttons.grid(row=0, column=3, padx=20)
        ttk.Button(nav_buttons, text="Previous", command=self.prev_image).pack(side=tk.LEFT, padx=5)
        ttk.Button(nav_buttons, text="Next", command=self.next_image).pack(side=tk.LEFT, padx=5)

        rotate_buttons = ttk.Frame(btn_frame)
        rotate_buttons.grid(row=0, column=5, padx=20)
        ttk.Button(rotate_buttons, text="Rotate Left", command=self.rotate_left).pack(side=tk.LEFT, padx=5)
        ttk.Button(rotate_buttons, text="Rotate Right", command=self.rotate_right).pack(side=tk.LEFT, padx=5)

        ttk.Button(btn_frame, text="Exit", command=self.win.destroy).grid(row=0, column=6, sticky="e", padx=25)

        self.show_image()

    def center_window(self):
        screen_width = self.win.winfo_screenwidth()
        screen_height = self.win.winfo_screenheight()
        x = (screen_width - WINDOW_WIDTH) // 2
        y = (screen_height - WINDOW_HEIGHT) // 2
        self.win.geometry(f"+{x}+{y}")

    def zoom_in(self):
        self.zoom_factor *= 1.2
        self.show_image()

    def zoom_out(self):
        self.zoom_factor = max(self.zoom_factor / 1.2, 0.1)
        self.show_image()

    def rotate_left(self):
        self.rotation_angle = (self.rotation_angle - 90) % 360
        self.show_image()

    def rotate_right(self):
        self.rotation_angle = (self.rotation_angle + 90) % 360
        self.show_image()

    def on_mouse_move(self, event):
        hdu = self.image_hdus[self.index]
        shape = hdu.data.shape
        x = event.x * shape[1] / self.canvas.winfo_width()
        y = shape[0] - (event.y * shape[0] / self.canvas.winfo_height())
        self.last_mouse_pos = (x, y)
        self.show_image(x, y)

    def show_image(self, mouse_x=None, mouse_y=None):
        hdu = self.image_hdus[self.index]
        data = hdu.data
        header = hdu.header

        norm_data = np.nan_to_num(data)
        norm_data = (norm_data - np.min(norm_data)) / (np.ptp(norm_data) + 1e-9)

        fig = plt.figure(figsize=(6 * self.zoom_factor, 6 * self.zoom_factor), dpi=100)
        plt.imshow(np.rot90(norm_data, k=self.rotation_angle // 90), cmap="gray", origin='lower')
        plt.axis('off')
        buf = io.BytesIO()
        plt.savefig(buf, format='png', bbox_inches='tight', pad_inches=0)
        plt.close(fig)
        buf.seek(0)
        img = Image.open(buf)
        photo = ImageTk.PhotoImage(img)

        self.canvas.configure(image=photo)
        self.canvas.image = photo

        self.info_text.delete("1.0", tk.END)
        self.info_text.insert(tk.END, f"HDU #{self.hdul.index(hdu)}\n")
        self.info_text.insert(tk.END, f"Shape: {data.shape}\n")
        self.info_text.insert(tk.END, f"Type: {type(hdu).__name__}\n")
        self.info_text.insert(tk.END, f"Zoom: {self.zoom_factor:.2f}x\n")
        self.info_text.insert(tk.END, f"Rotation: {self.rotation_angle}°\n")

        try:
            self.wcs = WCS(header)
            if mouse_x is not None and mouse_y is not None:
                ra, dec = self.wcs.pixel_to_world_values(mouse_x, mouse_y)
                self.info_text.insert(tk.END, f"RA: {ra:.6f}\n")
                self.info_text.insert(tk.END, f"DEC: {dec:.6f}\n")
        except Exception:
            self.info_text.insert(tk.END, "WCS: Not available\n")

        self.info_text.insert(tk.END, "\n")
        for key in ("OBJECT", "INSTRUME", "DATE-OBS", "EXPTIME"):
            if key in header:
                self.info_text.insert(tk.END, f"{key}: {header[key]}\n")

    def next_image(self):
        self.index = (self.index + 1) % len(self.image_hdus)
        self.show_image()

    def prev_image(self):
        self.index = (self.index - 1) % len(self.image_hdus)
        self.show_image()

    def on_mousewheel(self, event):
        if event.delta < 0:
            self.next_image()
        elif event.delta > 0:
            self.prev_image()

    def on_mousewheel_linux(self, event):
        if event.num == 4:
            self.prev_image()
        elif event.num == 5:
            self.next_image()

# ===== CONFIG =====
EXT = 1
PAGE_SIZE = 50

WINDOW_WIDTH = 1800
WINDOW_HEIGHT = 950

FONT_SIZE = 10
FONT_NAME = "Consolas"
BG_COLOR = "black"
FG_COLOR = "lime"
DEFAULT_COLUMN_WIDTH = 15
# ==================

class FITSViewer:
    def __init__(self, root, file_path):
        self.root = root
        self.root.title("FITS Viewer")
        
        # Set window size
        self.root.geometry(f"{WINDOW_WIDTH}x{WINDOW_HEIGHT}")
        # Center window
        self.center_window()

        self.font_size = FONT_SIZE
        self.column_width = DEFAULT_COLUMN_WIDTH
        self.page = 0

        # Open FITS file with lazy loading
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"File {file_path} not found.")
        self.hdul = fits.open(file_path, memmap=True)
        self.header = self.hdul[EXT].header
        self.colnames = self.hdul[EXT].columns.names
        self.nrows = self.hdul[EXT].header['NAXIS2']
        self.page_size = PAGE_SIZE

        # Layout
        main_frame = ttk.Frame(root)
        main_frame.pack(fill=tk.BOTH, expand=True)

        # Text output
        self.text = scrolledtext.ScrolledText(
            main_frame,
            font=(FONT_NAME, self.font_size),
            bg=BG_COLOR,
            fg=FG_COLOR
        )
        self.text.grid(row=0, column=0, padx=10, pady=10, sticky="nsew")
        self.text.bind("<MouseWheel>", self.on_mousewheel)
        self.text.bind("<Button-4>", self.on_mousewheel_linux)  # Linux scroll up
        self.text.bind("<Button-5>", self.on_mousewheel_linux)  # Linux scroll down

        # Column selection (right)
        col_frame = ttk.Frame(main_frame)
        col_frame.grid(row=0, column=1, padx=10, pady=10, sticky="ns")
        tk.Label(col_frame, text="Columns:").pack()
        self.column_listbox = tk.Listbox(col_frame, selectmode=tk.MULTIPLE, height=40, exportselection=False, width=30)
        self.column_listbox.pack(fill=tk.Y)
        for name in self.colnames:
            self.column_listbox.insert(tk.END, name)
        for i in range(min(10, len(self.colnames))):
            self.column_listbox.select_set(i)
        ttk.Button(col_frame, text="Update Columns", command=self.display_page).pack(pady=5)

        # Rows and Column Width input (side by side, centered in first row)
        input_frame = ttk.Frame(main_frame)
        input_frame.grid(row=1, column=0, columnspan=2, pady=5)
        main_frame.columnconfigure(0, weight=1)  # Center the input frame

        rows_frame = ttk.Frame(input_frame)
        rows_frame.pack(side=tk.LEFT, padx=5)
        tk.Label(rows_frame, text="Rows per Page:").pack(side=tk.LEFT)
        self.rows_entry = ttk.Entry(rows_frame, width=5)
        self.rows_entry.insert(0, str(self.page_size))
        self.rows_entry.pack(side=tk.LEFT, padx=5)
        ttk.Button(rows_frame, text="Set Rows", command=self.update_page_size).pack(side=tk.LEFT)

        width_frame = ttk.Frame(input_frame)
        width_frame.pack(side=tk.LEFT, padx=5)
        tk.Label(width_frame, text="Col Width:").pack(side=tk.LEFT)
        self.width_entry = ttk.Entry(width_frame, width=5)
        self.width_entry.insert(0, str(self.column_width))
        self.width_entry.pack(side=tk.LEFT, padx=5)
        ttk.Button(width_frame, text="Set Width", command=self.update_column_width).pack(side=tk.LEFT)

        # Controls (centered buttons)
        control_frame = ttk.Frame(main_frame)
        control_frame.grid(row=2, column=0, columnspan=2, pady=5)
        tk.Label(control_frame, text="Jump to page:").grid(row=0, column=0, padx=5)
        self.jump_entry = ttk.Entry(control_frame, width=5)
        self.jump_entry.grid(row=0, column=1, padx=5)
        ttk.Button(control_frame, text="Go", command=self.jump_to_page).grid(row=0, column=2, padx=5)
        ttk.Button(control_frame, text="Previous", command=self.prev_page).grid(row=0, column=3, padx=5)
        ttk.Button(control_frame, text="Next", command=self.next_page).grid(row=0, column=4, padx=5)
        ttk.Button(control_frame, text="A -", command=self.decrease_font).grid(row=0, column=5, padx=5)
        ttk.Button(control_frame, text="A +", command=self.increase_font).grid(row=0, column=6, padx=5)
        control_frame.columnconfigure(7, weight=1)  # Right padding

        # Image Viewer button (bottom left)
        image_frame = ttk.Frame(main_frame)
        image_frame.grid(row=2, column=0, padx=25, pady=5, sticky="w")  # Align to bottom left
        ttk.Button(image_frame, text="Show Image Viewer", command=self.open_image_viewer).pack(side=tk.LEFT)

        # Exit button (bottom right)
        exit_frame = ttk.Frame(main_frame)
        exit_frame.grid(row=2, column=1, padx=25, pady=5, sticky="e")  # Align to bottom right
        ttk.Button(exit_frame, text="Exit", command=self.root.quit).pack(side=tk.RIGHT)

        # Status
        self.status = ttk.Label(root, text=f"Page 1 of {int(self.nrows / self.page_size) + 1}, Total Rows: {self.nrows}")
        self.status.pack()

        main_frame.rowconfigure(0, weight=1)
        main_frame.columnconfigure(0, weight=1)

        self.display_page()

    def center_window(self):
        # Calculate window size
        screen_width = self.root.winfo_screenwidth()
        screen_height = self.root.winfo_screenheight()
        # Center window
        x = (screen_width - WINDOW_WIDTH) // 2
        y = (screen_height - WINDOW_HEIGHT) // 2
        self.root.geometry(f"+{x}+{y}")

    def get_selected_columns(self):
        indices = self.column_listbox.curselection()
        return [self.colnames[i] for i in indices] if indices else self.colnames[:10]

    def display_page(self):
        self.text.config(state='normal')
        self.text.delete("1.0", tk.END)
        start = self.page * self.page_size
        end = min(start + self.page_size, self.nrows)
        columns = self.get_selected_columns()

        header = "".join(name.ljust(self.column_width) for name in columns)
        self.text.insert(tk.END, header + "\n")
        self.text.insert(tk.END, "-" * len(header) + "\n")

        with fits.open(self.hdul.filename(), memmap=True) as hdul:
            data = hdul[EXT].data[start:end]
            for row in data:
                vals = [
                    str(row[name])[:self.column_width - 1].ljust(self.column_width) if not isinstance(row[name], (np.floating, np.integer)) or not np.isnan(row[name])
                    else "NaN".ljust(self.column_width) for name in columns
                ]
                self.text.insert(tk.END, "".join(vals) + "\n")

        self.text.config(state='disabled')
        self.status.config(text=f"Page {self.page + 1} of {int(self.nrows / self.page_size) + 1}, Total Rows: {self.nrows}, Displayed: {end - start}")

    def next_page(self):
        if (self.page + 1) * self.page_size < self.nrows:
            self.page += 1
            self.display_page()

    def prev_page(self):
        if self.page > 0:
            self.page -= 1
            self.display_page()

    def on_mousewheel(self, event):
        if event.delta < 0:
            self.next_page()
        elif event.delta > 0:
            self.prev_page()

    def on_mousewheel_linux(self, event):
        if event.num == 4:
            self.prev_page()
        elif event.num == 5:
            self.next_page()

    def increase_font(self):
        self.font_size += 1
        self.text.configure(font=(FONT_NAME, self.font_size))

    def decrease_font(self):
        if self.font_size > 6:
            self.font_size -= 1
            self.text.configure(font=(FONT_NAME, self.font_size))

    def update_column_width(self):
        try:
            new_width = int(self.width_entry.get())
            if new_width > 2:
                self.column_width = new_width
                self.display_page()
        except ValueError:
            self.status.config(text="Invalid column width")

    def update_page_size(self):
        try:
            new_size = int(self.rows_entry.get())
            if new_size > 0 and new_size <= 1000:  # Limit to reasonable range
                self.page_size = new_size
                self.page = 0  # Reset to first page
                self.display_page()
                self.status.config(text=f"Page 1 of {int(self.nrows / self.page_size) + 1}, Total Rows: {self.nrows}")
        except ValueError:
            self.status.config(text="Invalid number of rows")

    def jump_to_page(self):
        try:
            page_num = int(self.jump_entry.get()) - 1  # Convert to 0-based index
            max_page = int(self.nrows / self.page_size)
            if 0 <= page_num <= max_page:
                self.page = page_num
                self.display_page()
            else:
                self.status.config(text=f"Page must be between 1 and {max_page + 1}")
        except ValueError:
            self.status.config(text="Invalid page number")

    def open_image_viewer(self):
        ImageViewer(self.hdul)

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print("Usage: py fits_browser.py <fits_file_path>")
        sys.exit(1)
    file_path = sys.argv[1]
    root = tk.Tk()
    try:
        app = FITSViewer(root, file_path)
        root.mainloop()
    except FileNotFoundError as e:
        print(e)
        sys.exit(1)
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)
